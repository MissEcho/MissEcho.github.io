## html、css

### 1.如何理解css盒子模型

```
css的盒子模型，margin，padding。所有元素都是有对应的宽高。

// 标准的盒子模型：宽度=content+border+padding
低版本IE盒子模型：宽度=内容宽度（content+border+padding）
```

### 2.BFC

```
BFC，block formatting context。格式化上下文。
// 是web页面中盒模型布局的css渲染模式，指一个独立的渲染区域或者说是一个隔离容器。
形成条件是：
1.浮动元素，float除none之外的值。
2.定位元素，position，不会影响其他元素。
3.display为line-block，table-cell，table-caption
4.overflow除了visible（显示）之外的值
特性：
1.内部的box会在垂直方向上，一个接一个的放置。
2.垂直方向上，margin也算上。
3.BFC不会和float元素区域重叠
4.计算bfc的时候，浮动元素也算上
5.页面上独立的容器，而容器内部的元素，不会影响外面的元素。
```

### 3.标签语义化

```
必要性 & 好处：
1.方便dom结构分区。如果通篇都是div，这样的话，在非视觉阅览的情况下，很难准确描述文档内容。
2.减少不必要的css。一般语义标签都有自带的css样式，比如strong，h3等，可以减少一部分css的编写
3.方便维护。对页面的结构描述精准。//代码结构更加清晰
4.见名知意，没有基础的人也知道是干嘛的。
5.方便团队开发，代码可读性更强
6.有利于SEO，爬虫依赖于标签确定上下文关系
```

### 4.css和javascript引入设置

```
css可以通过link文件引入，也可以使用style标签在本地编写。
区别是，本地的会覆盖文件引入的。

javascript的引入，可以通过script src 引入，也可以在本地通过script编写。一般使用cdn加速。
//一般放在文档最后引入，1.因为如果js资源过大，容易造成加载时间过长页面白屏。渲染进程和js进行时互斥的，脚本会阻塞页面的渲染，但是脚本之间是同步进行的，按引入顺序执行。但也有属性控制js的加载和执行。比如 defer，async。2.如果js报错导致页面加载不出来。放文档后问题不大。3.
```

### 5.HTML的块级元素、行内元素、行内块元素的区别是什么

```
块级元素有：div，section，p，h1-6，ul，ol，dl，li，hr，dd，form，table等
行内元素：span，em，i,strong,a
行内块元素，img，input表单元素，一般使用display:block实现。
块级元素，独占一行，宽高生效，默认宽和父级一致，内容撑开高度，margin，padding生效；
行内元素，在当前行内，不会跨行；宽度根据内容来。左右margin生效上下不生效，
行内块元素，也是在当前行内，但是宽度根据width设置的值来确定，在一行排列。margin和爬到顶生效
```

### 6.CSS3的新特性

```
css3的新特性：
border-radius；border-image；border-width；box-shadow；text-shadow；linear-gradient;background;@meia媒体查询，用来解决移动端适配，根据屏幕大小使相应的css生效。

因为css发展到现在，基本上规范都是根据模块来划分的了。比如css grid，css builde等。后面是根据这些模块的版本来命名。后面也不会有css4这类名称了。
css3的新特性，有calc，计算属性。有类似于sass的变量命名；
```

### 7.实现元素隐藏

```
1.display:none;
2.width:0;height:0
3.透明度为0，opacity:0
4.float or position移动到页面边缘
5.z-index隐藏到其他元素下面
6.visibility:hidden,
```

### 8.如何实现元素水平居中

```
1.margin:0 auto;(对块级元素有用)
2.position+left;(已知本身的宽度)
3.text-align:center;(父级元素是block，子元素是行内or 行内块级元素)
4.padding(已知父级和子元素宽度)
5.flex 
6.grid
```

### 9.如何实现元素垂直居中

```
1.flex
2.position+top(已知父子高度)
3.grid
4.line-heigt:height;
5.verticle-align:middle;
```

###  10.position

```
默认是static，
relative，相对定位。不脱离文档流，相对于自身位置进行偏离，不影响本身特性，z-index提高层级。
absolute，脱离文档流，而在相对于父级进行定位。
fixed的时候，是根据视窗进行定位
```

### 11.解释下浮动和原理，如何清除浮动

```
为什么有浮动:因为元素之间的
浮动元素父元素高度自适应（父元素不写高度的时候，子元素写了浮动，父元素会发生高度塌陷。）
因为本来父元素的高度是靠子元素的内容高度来撑起来的，但你写了浮动，半脱离了文档流（占据了该位置，但是对父级没有高度内容，也会影响旁边元素的布局。浮动原本被设计出来的作用是实现文字环绕效果的），就相当于这部分高度没了。所以要清除浮动。
{
	clear:both;
	height:0;
	overflow:hidden;
}

清除浮动：
1.给浮动元素的父级增加高度（防止高度塌陷）
2.父级同时浮动
3.父级设置inline-block，行内块级元素，或者增加overflow:hidden;清除浮动
4.:after清除
5.增加一个标签，设置clear:both,会导致增加无意义标签。
```

### 12.css的选择器，优先级是哪些

```
1. 标签
2. #id
3. .class
4. 标签[title=]属性
5. 伪类
6. 通配符
```

### 13.各种布局的优缺点

```
1.grid布局（和flex相似）
2.flex布局（不支持IE8及以下）
3.position布局（有效性和可使用性比较差）
4.float布局（需要手动清除浮动，容易造成高度塌陷）
5.table布局（容易联动更改）
```

### 14.html5的新特性，移除了哪些元素。如何处理html5元素的兼容问题，如何区别html和html5

```
html5的新特性：增加了section标签，

移除元素：
1.纯表现元素：big，center，font，s，strike
2.对可用性产生负面影响的元素：frame，frameset，noframes；

兼容问题：使用优雅降级
比如通过document.createElement方法产生标签，利用这个特性让浏览器支持html5新标签。当然最好是直接使用成熟的框架，使用最多的是html5shim框架。

区别在于头部的DOCTYPE声明、新增的结构元素、功能元素等。
```

### 15.解释盒模型宽高值的计算方式，边界塌陷，负值作用。box-sizing的概念。

```
盒模型的宽高：宽=内容宽度；高=元素的高度+padding
IE678的盒模型：宽度=边框+padding+内容宽度；
边界塌陷：因为子元素撑不起父级的高度，导致对其他元素的影响。块元素的top和bottom外边距有时候会合并为单个外边距。成为外距塌陷。
负值：使用负值让元素往相反方向运动。比如margin:-5px 0 0 0;则表示往上5px挪动
box-sizing:是为了解决标准盒子模型和IE盒子的不同，css3新增了盒模型属性box-sizing，content-box（默认值），border-box(让元素维持IE盒子传统模型)，inherit继承盒子模型
```

### 16.如何实现浏览器内，多个标签的通信？

```
1.同一个域名下，使用cookie，localstorage通信；
2.不同域名下，使用ajax通信
```



## JS

### 1.什么是闭包

```
在函数内部的函数，也就是说内部函数持有外部函数变量的引用。
即拥有其他函数变量引用的函数。
```

### 2.闭包的用途

```
1.读取函数内部的变量，更改函数内部的变量。
2.让这些值一直存在内存中，不会在f1调用后被清除。
3.方便上下文的局部变量，利于代码封装。

有权访问另一个函数变量的函数都是叫做闭包。
f1，是f2的父函数。f2被赋给了全局变量，f2始终存在于内存中,f2的存在依赖于f1，因此f1也始终存在内存中，不会在调用后，被垃圾回收机制回收。
因为在js中，各个函数是独立的，可以获取作用域内的信息。但是作用域内无法获取函数内部的信息，所以这就需要闭包。在库封装的时候，就需要使用到闭包
```

### 3.闭包的缺点

```
1.容易内存泄露。因为闭包使得函数的变量都保存在内存中，内存消耗很大，所以不能滥用，不然会导致性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不要的局部变量全部删除。
2.闭包在父函数之外，所以不能随意更改父函数内部的值。不然很难定位问题。比如，你把父函数当做对象，把闭包当做方法，吧内部变量当做私有变量，那就最好不要随意在闭包中更改私有变量。
```

### 4.闭包的应用场景

```
1.函数防抖
2.使用闭包设计单例模式
3.多个组件独立属性
4.设置私有变量
5.拿到正确的值。（也可以通过let）
```

### 5.js的数据类型

```
1.stirng
2.number
3.boolean
4.object(引用类型，主要是对象、数组和函数)
5.null
6.undefined
7.symbol
```

### 6.基本数据类型和引用数据类型的区别是什么

```
1.存储方式不同。基本类型是直接存在栈里的。而引用类型是，指针变量存在栈里，指针指向的数据实体存在堆里。
2.作为函数参数进行传递时，基本类型传入的是副本，原数据的更改不会影响传入后的值。引用类型传入的是引用地址，原数据的更改会改变传入后的数据。
```

### 7.判断数据类型

```
1.typeof(判断null会等于object)
2.instanceof(无法判断null和undefined)，检测A是否为B的实例
3.constructor ==A 可以判断A是否为B的原型。constructor还可以检测基本数据类型。（不过容易重写，）
4.
```

## 8.浅拷贝和深拷贝

```
浅拷贝：
1.通过JSON.stringify和JSON.parse就可以获得。
2.object.assign(),如果目标是一层的话，等同于深拷贝。
3.扩展符运算
深拷贝：
1.一般来说只能靠手写递归复制了
```

### 9.let和const的区别是什么

```
let 和const 都是声明所在的块作用域内有效。 
let 即在当前作用域下生效的变量。变量可以改变，值和类型都可以改变。
const是常量声明，即一旦声明之后，要立即初始化。一般赋值之后，变量不可再次赋值。而const声明一个引用类型的话，则需要非常小心。因为const只保证地址不变。而数据是可变的。
如果想让引用类型的内部数据不能修改，可以使用object.freeze()。
```

### 10.什么是执行上下文和执行栈

```
执行上下文，决定了变量或函数可以访问哪些数据。每个上下文都有一个变量对象，所有可以访问的变量和函数都存在该对象里。DOM的顶层对象是window，可以省略。每个函数都有自己的上下文。
在执行到该函数的时候，就把函数上下文推入执行栈中，当执行结束之后，所有上下文变量都会被销毁，并把控制权返回给之前执行的上下文。
js的执行流就是通过这个执行栈控制的。
```

### 11.什么是作用域和作用域链

```
作用域，即变量或者函数能够生效的范围。作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。ES6中有全局作用域、函数作用域、块作用域三种类型。
当一个变量在当前作用域没有找到的话，会一级一级往上找，直到全局作用域为止，这种串起来的关系就是作用域。
```

### 12.作用域和执行上下文的区别是什么

```
1.执行上下文只在函数被调用的时候生成，而其作用域在创建的时候就生成了。
2.函数的作用域会包含若干个执行上下文。（也可能是0个，因为没有被调用）
```

### 13.this指向的各种情况都有什么

```
this指向
1.构造函数（this指向生成的实例）
2.执行上下文的对象（对象内部的函数，则this指向对象本身）
3.全局对象 （全局作用域的函数，this指向window）
4.apply、call、bind改造的函数，则指向第一个参数
5.箭头函数，没有自己的this，如果外部有函数的话，则指向外部函数，如果没有则指向window
```

### 14.如何改变this指针的指向

```
使用apply、call、bind方法改变this指向，但又不会改变函数的作用域。
apply、bind的第二个参数都是数组，call接收多个参数并用逗号隔开；
apply、call只对原函数做改动，bind会返回新的函数（如果要执行还要再调用一遍）
```

### 15.如何理解异步和同步？

```
同步，即一件一件的做完；按照代码执行顺序
异步，即可以同时做几件事。并行处理
js之所以需要异步的原因是js为单线程运行的。所以需要异步场景，比如定时器、ajax、事件绑定。
```

### 16. js是如何实现异步的

```
js引擎是单线程的。但是能通过事件循环和任务队列的模式来实现异步。


js只有一个线程，称之为主线程。事件循环是在主线程中执行栈里的代码执行完毕之后，才开始执行的。

1.通过promise
2.通过微任务和宏任务来区分的。

setimeout是属于微任务，
```

### 17.什么是ajax，如何实现

```
ajax是浏览器和服务端进行异步通信的协议。
ajax是一种能够实现页面局部刷新的技术，可以使页面进行异步刷新。
页面or浏览器端通过发起http请求。
1.创建核心的XMLhttpRequest;
2.利用open方法打开与服务器的链接；
3.利用send方法发送请求，post请求的话，还需要额外设置请求头。
4.监听服务器响应,接受返回值.
```

### 18.实现异步的方式有哪些

```
1.promise
2.回调函数模式
3.事件监听模式
4.发布订阅模式
5.async、await（基于promise实现的异步函数）
6.利用生成器实现
```










## vue

### 1.vue的优点

```
1.数据双向绑定，减少了dom的操作次数
2.增加了虚拟dom，减少了重绘次数，提高性能
3.简单易学，国人框架，中文文档
4.轻量级框架，渐进式使用
5.组件化，和react优点一致，实现了html的封装和重用。在构建单页应用方面有天然优势。
```

### 2.vue父子组件通信

````
父级——>子级
1.props

子级——>父级
1.this.$emit方法
````

 ### 3.v-show和v-if指令的共同点和不同点

```
都是接受一个布尔值控制元素的显示隐藏。
只是v-show的话，会是display:none，只会编译一次。
v-if的话，是直接移出dom，所以会比较消耗性能。
```

### 4.如何让css只在当前组件生效

```
在style标签上增加scoped
但是这样的话，无法重写样式。（即引入组件的样式无法重写）
```

### 5.keep-alive的作用是什么

```
keep-alive是vue内置的一个组件，可以使被包含的组件保留状态，或者说避免重新渲染。即缓存。
```

### 6.如何获取dom

```
在vue中获取dom，通过refs获取，即在dom结构上 使用ref属性，
```

### 7.说出几种vue的指令和用法

```
1.v-text给innerText赋值，v-html用于插入innerHTML
2.v-model:双向数据绑定
3.v-for：循环
4.v-if，v-show
5.v-on：监听
6.v-once：只绑定一次
```

### 8.vue-loader是什么，用途？

```
vue文件的一个加载器，讲template\js\style转成js模块；
js可以写es6，style样式可以使用scss或less，template可以加jade等
```

### 9.为什么使用key

```
需要使用key来给每个节点做一个唯一标志，Diff算法可以正确的识别此节点。作用主要是为了高校的更新虚拟DOM
```

### 10.axios及安装

```
请求后台资源的模块。axios是一个封装好的ajax库，返回在.then函数中，失败在catch函数中。
安装的话，可以通过node npm依赖安装。然后使用import进来。
```

### 11.v-model的作用

```
用于数据双向绑定。是一个语法糖
1.v-bind绑定一个value属性
2.v-on监听当前元素绑定的input事件
```

### 12.请说出vue.cli项目中src目录每个文件夹和文件的用法？

```
src/component(公共组件)
src/router(路由页面)
src/assets（静态资源）
src/app.vue（应用主组件）
src/main.js（入口文件）
```

### 13.简述computed和watch的场景

```
computed:用于计算属性。比如要通过监听多个值来计算某一个值的时候，就需要用computed，比如购物车结算。
watch用于监听单个属性的变化，即一条数据影响多条。或者说某个对象的深度监听，比如搜索框
```

### 14.v-on可以监听多个方法吗

```
可以，逗号隔开。
```

### 15.$nextTick

```
nextTick,
```

