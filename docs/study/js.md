## 变量和类型

### 1.js几种基本类型

现在有6种常用类型，1种大数据类型，1种es6新增类型。

- null （typeof null ==Object。这个是历史遗留问题，因为typeof是根据二进制的前三位来判断的，而null和object的前三位都是000，所以误判了。但是后面没有更改回来。）
- undefined （这个表示是无效值。如果对象中属性值是undefined，那在JSON.stringify过程中会被丢弃掉。）
- boolean（会产生隐式转换）
- string（字面量和new装箱拆箱是不一样的）
- number（一样会产生隐式转换）
- object（）
- BigInt（使用场景很少）
- Symbol（基本上很少用到。除非做一个特殊无实际内容的区分。）



### 2.对象的底层数据结构是什么

对象的底层可以看做是一个属性的无序集合。js中所有事物都是对象（函数、数组、、、）。







### 3.Symbol在实际应用开发中的作用，手动实现一个Symbol

其实我个人感觉symbol在实际中没有太大作用。可能是因为我现在的项目级别不够大，所以应用不多的原因。但这并不妨碍我去理解作者新增symbol类型的原因。

symbol在全局唯一，





### 4.js变量在内存中存储的形式

基本类型比如null，undefined，string，number，boolean都是以值的方式存在内存中的。变量名和变量值都是存在内存的栈区。



而Object类型包括array等引用类型，是以内存地址的形式存在变量当中的。所以复制引用对象，并不是复制了值，只是复制了引用地址而已。

变量标识也存放在栈区，对象存在堆区。而对象的地址存储在栈区。



### 5.基本类型对应的内置对象，以及他们的装箱拆箱操作

- null—object
- undefined—undefined
- boolean—Boolean
- number—Number
- string—String
- object—Object
- Symbol—Symbol
- bigInt

装箱：把基本的数据类型转为对应的引用类型

new String()



拆箱：把引用类型转为基本类型

toSting()



### 6.理解值类型和引用类型

值类型：内存控件固定，保存在栈中。保存和复制的是本身，使用typeof检测类型；



引用类型：占用空间不固定，保存在堆中。





### 7.null和undefined的区别

null是表示该变量存在，但是值为空。

而undefined则表示该变量为无效值。如果对象的属性值是undefined的话，那在转json.stringify的时候就会被丢弃。但是在for...in或者keys等api里面还是可以循环出来的。

''表示是一个空的字符串。



### 8.至少说出三种判断数据类型的方法，以及他们的优缺点。以及准确的判断数组类型。





### 9.可能发生隐式转换的，以及如何利用该规则巧妙应用



###  10.精度问题

0.1+0.2  != 0.3  

因为计算机在计算的时候转为了二进制，所以浮点数位数过长会被截取掉，然后再转为十进制的时候会不一致。









## 原型链和函数

### 1.理解原型设计模式以及js中的原型规则





### 2.instanceof的底层实现原理，手动实现一个instanceof

instanceof判断某个实例，是否属于某个类型。

底层实现原理就是判断右边变量的原型，是否存在左边的原型链上。

除了instanceof，还有isPropertypeOf()

获取当前对象的原型链。



class和function创建对象的区别





### 3.实现继承的几种方式



### 4.至少一种开源项目





### 5.理解es6的class构造及继承的底层实现原理









